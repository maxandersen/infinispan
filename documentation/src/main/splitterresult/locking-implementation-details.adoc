ifdef::context[:parent-context: {context}]
[id="locking-implementation-details_{context}"]
= Locking implementation details
:context: locking-implementation-details

{brandname}'s MVCC implementation makes use of minimal locks and synchronizations, leaning heavily towards lock-free techniques such as link:http://en.wikipedia.org/wiki/Compare-and-swap[compare-and-swap] and lock-free data structures wherever possible, which helps optimize for multi-CPU and multi-core environments.

In particular, {brandname}'s MVCC implementation is heavily optimized for readers.
Reader threads do not acquire explicit locks for entries, and instead directly read the entry in question.

Writers, on the other hand, need to acquire a write lock.
This ensures only one concurrent writer per entry, causing concurrent writers to queue up to change an entry.

To allow concurrent reads, writers make a copy of the entry they intend to modify, by wrapping the entry in an `MVCCEntry`.
This copy isolates concurrent readers from seeing partially modified state.
Once a write has completed, `MVCCEntry.commit()` will flush changes to the data container and subsequent readers will see the changes written.

include::modules/how-does-it-work-in-clustered-caches.adoc[leveloffset=+1]

include::modules/transactional-caches.adoc[leveloffset=+1]

include::modules/isolation-levels.adoc[leveloffset=+1]

include::modules/the-lockmanager.adoc[leveloffset=+1]

include::modules/lock-striping.adoc[leveloffset=+1]

include::modules/concurrency-levels.adoc[leveloffset=+1]

include::modules/lock-timeout.adoc[leveloffset=+1]

include::modules/consistency.adoc[leveloffset=+1]


ifdef::parent-context[:context: {parent-context}]
ifndef::parent-context[:!context:]