ifdef::context[:parent-context: {context}]
[id="hot-rod-protocol-2-6_{context}"]
= Hot Rod Protocol 2.6
:context: hot-rod-protocol-2-6

.Infinispan versions
[TIP,textlabel="Tip",name="tip"]
====
This version of the protocol is implemented since Infinispan 9.0
====

This Hot Rod protocol version adds support for streaming get and put operations.
It includes two new operations:

* GetStream for retrieving data as a stream, with an optional initial offset
* PutStream for writing data as a stream, optionally by specifying a version

.GetStream
[]
Request (0x37):

[table,tablepcwidth="100",rowcount="5",header-option="",colcount="3",cols="3,^2,10"]
|===
| Header | variable | Request header
| Offset | vInt | The offset in bytes from which to start retrieving. Set to 0 to retrieve from the
beginning
| Key Length | vInt | Length of key. Note that the size of a
vint can be up to 5 bytes which in theory can produce bigger numbers than
Integer.MAX_VALUE. However, Java cannot create a single array that’s bigger
than Integer.MAX_VALUE, hence the protocol is limiting vint array lengths to
Integer.MAX_VALUE.
| Key | byte array | Byte array containing the key whose value is being requested.
|===

.GetStream
[]
Response (0x38):

[table,tablepcwidth="100",rowcount="11",header-option="",colcount="3",cols="3,^2,10"]
|===
| Header | variable | Response header
| Response status | 1 byte | +0x00+ = success, if key retrieved +
+0x02+ = if key does not exist +
| Flag | 1 byte | A flag indicating whether the response
contains expiration information. The value of the flag is obtained as a
bitwise OR operation between +INFINITE_LIFESPAN (0x01)+ and
`INFINITE_MAXIDLE (0x02)`.
| Created | Long | (optional) a Long representing the
timestamp when the entry was created on the server. This value is returned
only if the flag's +INFINITE_LIFESPAN+ bit is not set.
| Lifespan | vInt | (optional) a vInt representing the
lifespan of the entry in seconds. This value is returned only if the flag's
+INFINITE_LIFESPAN+ bit is not set.
| LastUsed | Long | (optional) a Long representing the
timestamp when the entry was last accessed on the server. This value is
returned only if the flag's `INFINITE_MAXIDLE` bit is not set.
| MaxIdle | vInt | (optional) a vInt representing the
maxIdle of the entry in seconds. This value is returned only if the flag's
`INFINITE_MAXIDLE` bit is not set.
| Entry Version | 8 bytes | Unique value of an existing entry's modification.
The protocol does not mandate that entry_version values are sequential.
They just need to be unique per update at the key level.
| Value Length | vInt | If success, length of value
| Value | byte array | If success, the requested value
|===

.PutStream
[]
Request (0x39)

[table,tablepcwidth="100",rowcount="8",header-option="",colcount="3",cols="3,^2,10"]
|===
| Header | variable | Request header
| Entry Version | 8 bytes | Possible values +
0 = Unconditional put +
-1 = Put If Absent +
Other values =  pass a version obtained by `GetWithMetadata` operation to perform a conditional replace.
| Key Length | vInt | Length of key. Note that the size of a
vint can be up to 5 bytes which in theory can produce bigger numbers than
Integer.MAX_VALUE. However, Java cannot create a single array that’s bigger
than Integer.MAX_VALUE, hence the protocol is limiting vint array lengths to
Integer.MAX_VALUE.
| Key | byte array | Byte array containing the key whose value is being requested.
| Value Chunk 1 Length | vInt | The size of the first chunk of data. If this value is 0 it means the client has
 completed transferring the value and the operation should be performed.
| Value Chunk 1 | byte array | Array of bytes forming the fist chunk of data.
| ...continues until the value is complete |  | 
|===

Response (0x3A):

[table,tablepcwidth="100",rowcount="2",header-option="",colcount="3",cols="3,^2,10"]
|===
| Header | variable | Response header
|===

On top of these additions, this Hot Rod protocol version improves remote listener registration by adding a byte that indicates at a global level, which type of events the client is interested in.
For example, a client can indicate that only created events, or only expiration and removal events...etc.
More fine grained event interests, e.g. per key, can be defined using the key/value filter parameter.

So, the new add listener request looks like this:

.Add client listener for remote events
[]
Request (0x25):

[table,tablepcwidth="100",rowcount="15",header-option="",colcount="3",cols="3,^2,10"]
|===
| Header | variable | Request header
| Listener ID | byte array | Listener identifier
| Include state | byte | When this byte is set to `1`, cached state is
sent back to remote clients when either adding a cache listener for the first
time, or when the node where a remote listener is registered changes in a clustered
environment. When enabled, state is sent back as cache entry created events to
the clients. If set to `0`, no state is sent back to the client when adding a listener,
nor it gets state when the node where the listener is registered changes.
| Key/value filter factory name | string | Optional name of the key/value filter
factory to be used with this listener. The factory is used to create key/value
filter instances which allow events to be filtered directly in the Hot Rod
server, avoiding sending events that the client is not interested in. If no
factory is to be used, the length of the string is `0`.
| Key/value filter factory parameter count | byte | The key/value filter
factory, when creating a filter instance, can take an arbitrary number of
parameters, enabling the factory to be used to create different filter
instances dynamically. This count field indicates how many parameters will be
passed to the factory. If no factory name was provided, this field is not
present in the request.
| Key/value filter factory parameter 1 | byte array | First key/value filter
factory parameter
| Key/value filter factory parameter 2 | byte array | Second key/value filter
factory parameter
| ... |  | 
| Converter factory name | string | Optional name of the converter
factory to be used with this listener. The factory is used to transform the
contents of the events sent to clients. By default, when no converter is in use,
events are well defined, according to the type of event generated. However,
there might be situations where users want to add extra information to the event,
or they want to reduce the size of the events. In these cases, a converter can
be used to transform the event contents. The given converter factory name
produces converter instances to do this job. If no factory is to be used, the
length of the string is `0`.
| Converter factory parameter count | byte | The converter
factory, when creating a converter instance, can take an arbitrary number of
parameters, enabling the factory to be used to create different converter
instances dynamically. This count field indicates how many parameters will be
passed to the factory. If no factory name was provided, this field is not
present in the request.
| Converter factory parameter 1 | byte array | First converter factory parameter
| Converter factory parameter 2 | byte array | Second converter factory parameter
| ... |  | 
| Listener even type interests | vInt | A variable length number representing listener event type interests.
Each event type is represented by a bit.
Each flags is represented by a bit.
Note that since this field is sent as variable length, the most significant bit in a byte is used to determine whether more bytes need to be read, hence this bit does not represent any flag.
Using this model allows for flags to be combined in a short space.
Here are the current values for each flag: +
+0x01+ = cache entry created events
+0x02+ = cache entry modified events
+0x04+ = cache entry removed events
+0x08+ = cache entry expired events
|===


ifdef::parent-context[:context: {parent-context}]
ifndef::parent-context[:!context:]