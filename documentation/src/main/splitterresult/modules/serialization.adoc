[id="serialization_{context}"]
= Serialization

Since the operations are sent across to other nodes they must be serializable by {brandname} marshalling.  This allows the
operations to be sent to the other nodes.

The simplest way is to use a CacheStream instance and use a lambda just as you would normally.
{brandname} overrides all of the various Stream intermediate and terminal methods to take
Serializable versions of the arguments (ie. SerializableFunction, SerializablePredicate...)
You can find these methods at
link:{javadocroot}/org/infinispan/stream/CacheStream.html[CacheStream].
This relies on the spec to pick the most specific method as defined link:https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2.5[here].

In our previous example we used a `Collector` to collect all the results into a `Map`.
Unfortunately the link:{jdkdocroot}/java/util/stream/Collectors.html[Collectors]
class doesn't produce Serializable instances.  Thus if you need to use these, there are two ways to do so:

One option would be to use the
link:{javadocroot}/org/infinispan/stream/CacheCollectors.html[CacheCollectors]
class which allows for a `Supplier<Collector>` to be provided.  This instance could then use the
link:{jdkdocroot}/java/util/stream/Collectors.html[Collectors]
to supply a `Collector` which is not serialized.

[source,java]
----
Map<Object, String> jbossValues = cache.entrySet().stream()
              .filter(e -> e.getValue().contains("Jboss"))
              .collect(CacheCollectors.serializableCollector(() -> Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)));
----

Alternatively, you can avoid the use of
link:{javadocroot}/org/infinispan/stream/CacheCollectors.html[CacheCollectors]
and instead use the overloaded `collect` methods that take `Supplier<Collector>`.
These overloaded `collect` methods are only available via `CacheStream` interface.

[source,java]
----
Map<Object, String> jbossValues = cache.entrySet().stream()
              .filter(e -> e.getValue().contains("Jboss"))
              .collect(() -> Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
----

If however you are not able to use the `Cache` and `CacheStream` interfaces you cannot utilize `Serializable`
arguments and you must instead cast the lambdas to be `Serializable` manually by casting the lambda to multiple
interfaces.  It is not a pretty sight but it gets the job done.

[source,java]
----
Map<Object, String> jbossValues = map.entrySet().stream()
              .filter((Serializable & Predicate<Map.Entry<Object, String>>) e -> e.getValue().contains("Jboss"))
              .collect(CacheCollectors.serializableCollector(() -> Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)));
----

The recommended and most performant way is to use an
`AdvancedExternalizer` as this provides the smallest payload.  Unfortunately
this means you cannot use lamdbas as advanced externalizers require defining
the class before hand.

You can use an advanced externalizer as shown below:

[source,java]
----
   Map<Object, String> jbossValues = cache.entrySet().stream()
              .filter(new ContainsFilter("Jboss"))
              .collect(() -> Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));

   class ContainsFilter implements Predicate<Map.Entry<Object, String>> {
      private final String target;

      ContainsFilter(String target) {
         this.target = target;
      }

      @Override
      public boolean test(Map.Entry<Object, String> e) {
         return e.getValue().contains(target);
      }
   }

   class JbossFilterExternalizer implements AdvancedExternalizer<ContainsFilter> {

      @Override
      public Set<Class<? extends ContainsFilter>> getTypeClasses() {
         return Util.asSet(ContainsFilter.class);
      }

      @Override
      public Integer getId() {
         return CUSTOM_ID;
      }

      @Override
      public void writeObject(ObjectOutput output, ContainsFilter object) throws IOException {
         output.writeUTF(object.target);
      }

      @Override
      public ContainsFilter readObject(ObjectInput input) throws IOException, ClassNotFoundException {
         return new ContainsFilter(input.readUTF());
      }
   }
----

You could also use an advanced externalizer for the collector supplier to reduce the
payload size even further.

[source,java]
----
   Map<Object, String> jbossValues = cache.entrySet().stream()
              .filter(new ContainsFilter("Jboss"))
              .collect(ToMapCollectorSupplier.INSTANCE);

 class ToMapCollectorSupplier<K, U> implements Supplier<Collector<Map.Entry<K, U>, ?, Map<K, U>>> {
      static final ToMapCollectorSupplier INSTANCE = new ToMapCollectorSupplier();

      private ToMapCollectorSupplier() { }

      @Override
      public Collector<Map.Entry<K, U>, ?, Map<K, U>> get() {
         return Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue);
      }
   }

   class ToMapCollectorSupplierExternalizer implements AdvancedExternalizer<ToMapCollectorSupplier> {

      @Override
      public Set<Class<? extends ToMapCollectorSupplier>> getTypeClasses() {
         return Util.asSet(ToMapCollectorSupplier.class);
      }

      @Override
      public Integer getId() {
         return CUSTOM_ID;
      }

      @Override
      public void writeObject(ObjectOutput output, ToMapCollectorSupplier object) throws IOException {
      }

      @Override
      public ToMapCollectorSupplier readObject(ObjectInput input) throws IOException, ClassNotFoundException {
         return ToMapCollectorSupplier.INSTANCE;
      }
   }
----